# Imports
library('geoR')
model <- 'new_model1'
k0_dat_csv <- read.csv(file = sprintf("/Users/tnye/kappa/krige/%s_coords.csv", model))
lon <- k0_dat_csv['Longitude']
lat <- k0_dat_csv['Latitude']
UTMx <- k0_dat_csv['UTMx']
UTMy <- k0_dat_csv['UTMy']
log_k <- k0_dat_csv['log10_kappa']
kappa <- k0_dat_csv['kappa']
covariates <- numeric(length(log_k))
### Longitude Latitude
df <- data.frame("Longitude"=lon, "Latitude"=lat, "data"=kappa, "covariates"=covariates)
data <- as.geodata(df, coords.col=1:2, data.col=3, covar.col=4,
"station_names"=df$station_names, data.names=NULL, covar.names="BAY")
saveRDS(data, file = sprintf("/Users/tnye/kappa/krige/%s_my_data_lonlat.rds", model))
### UTM
df <- data.frame("UTMx"=UTMx, "UTMy"=UTMy, "data"=kappa, "covariates"=covariates)
data <- as.geodata(df, coords.col=1:2, data.col=3, covar.col=4,
"station_names"=df$station_names, data.names=NULL, covar.names="BAY")
saveRDS(data, file = sprintf("/Users/tnye/kappa/krige/%s_my_data_utm.rds", model))
##################################################################################
# R code to read station k0 data and produce a spatially-continuous map for the
# San Francisco Bay area. Code modified from
# https://github.com/cvanhoutte-zz/kappa/blob/master/codes/krige.R
#
# Requires R packages {geoR} and {pracma}.
#
##################################################################################
# Imports
library('geoR')
library('pracma')
library('gstat')
library(sp)
# Name of model
model_name <- 'new_model1'
# Read data for kappa estimates from rds file and turn into a dataframe:
# - Coordinates are degrees lon and lat
k0rds <- readRDS(sprintf("/Users/tnye/kappa/krige/%s_my_data.rds", model_name))
kappa <- k0rds$data
longitude <- k0rds$coords[,1]
latitude <- k0rds$coords[,2]
k0.data <- data.frame(longitude, latitude, kappa)
# Define coordinates
coordinates(k0.data) = ~longitude+latitude
# Initial values for regression (from Van Houtte et al., 2018)
ini.nug <- 0
ini.sill <- 0.03
ini.range <- 0.1
# Matern order (fixed) (from Van Houtte et al., 2018)
theta <- 0.5
# Make and plot variogram
# k0.vgm = variogram(kappa~1, k0.data)
# k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Mat', ini.range, kappa=theta, nugget=ini.nug))
k0.vgm = variogram(kappa~1, k0.data)
k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Sph', ini.range, nugget=ini.nug))
# Save plot of variogram
png(file=sprintf('/Users/tnye/kappa/plots/paper/k0_semivariogram_%s.png',model_name),
width=600, height=350, res=300)
plot(k0.vgm, k0.fit, xlab="Distance (deg)", ylab="Semivariance",cex.lab=.5,cex.axis=.5)
dev.off()
# Kriging 1 --------------------------------------------------------------------
grid <- read.csv("/Users/tnye/kappa/krige/grid_lonlat.txt")
coordinates(grid) = ~Longitude+Latitude
k0.kriged = krige(kappa~1, k0.data, grid, model = k0.fit)
spplot(k0.kriged["var1.pred"])
# Krige Predictions (in linear, not log10 units)
k0.pred <- k0.kriged$var1.pred
# Krige Standard deviations
k0.stddev <- sqrt(k0.kriged$var1.var)
# Make Dataframe
df <- data.frame("Latitude"=grid[,2], "Longitude"=grid[,1], "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
write.csv(df, sprintf("/Users/tnye/kappa/krige/%s_krige_k0_linear.csv", model_name), row.names = FALSE)
##################################################################################
# R code to read station k0 data and produce a spatially-continuous map for the
# San Francisco Bay area. Code modified from
# https://github.com/cvanhoutte-zz/kappa/blob/master/codes/krige.R
#
# Requires R packages {geoR} and {pracma}.
#
##################################################################################
# Imports
library('geoR')
library('pracma')
library('gstat')
library(sp)
# Name of model
model_name <- 'new_model1'
# Read data for kappa estimates from rds file and turn into a dataframe:
# - Coordinates are degrees lon and lat
k0rds <- readRDS(sprintf("/Users/tnye/kappa/krige/%s_my_data.rds", model_name))
kappa <- k0rds$data
longitude <- k0rds$coords[,1]
latitude <- k0rds$coords[,2]
k0.data <- data.frame(longitude, latitude, kappa)
# Define coordinates
coordinates(k0.data) = ~longitude+latitude
# Initial values for regression (from Van Houtte et al., 2018)
ini.nug <- 0
ini.sill <- 0.03
ini.range <- 0.1
# Matern order (fixed) (from Van Houtte et al., 2018)
theta <- 0.5
# Make and plot variogram
# k0.vgm = variogram(kappa~1, k0.data)
# k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Mat', ini.range, kappa=theta, nugget=ini.nug))
k0.vgm = variogram(kappa~1, k0.data)
k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Sph', ini.range, nugget=ini.nug))
# Save plot of variogram
png(file=sprintf('/Users/tnye/kappa/plots/paper/k0_semivariogram_%s.png',model_name),
width=600, height=350, res=300)
plot(k0.vgm, k0.fit, xlab="Distance (deg)", ylab="Semivariance",cex.lab=.5,cex.axis=.5)
dev.off()
# Kriging 1 --------------------------------------------------------------------
grid <- read.csv("/Users/tnye/kappa/krige/grid_lonlat.txt")
coordinates(grid) = ~Longitude+Latitude
k0.kriged = krige(kappa~1, k0.data, grid, model = k0.fit)
spplot(k0.kriged["var1.pred"])
# Krige Predictions (in linear, not log10 units)
k0.pred <- k0.kriged$var1.pred
# Krige Standard deviations
k0.stddev <- sqrt(k0.kriged$var1.var)
# Make Dataframe
df <- data.frame("Latitude"=grid[,2], "Longitude"=grid[,1], "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
write.csv(df, sprintf("/Users/tnye/kappa/krige/%s_krige_k0_linear.csv", model_name), row.names = FALSE)
# Imports
library('geoR')
library('pracma')
library('gstat')
library(sp)
# Name of model
model_name <- 'new_model1'
# Read data for kappa estimates from rds file and turn into a dataframe:
# - Coordinates are degrees lon and lat
k0rds <- readRDS(sprintf("/Users/tnye/kappa/krige/%s_my_data.rds", model_name))
kappa <- k0rds$data
longitude <- k0rds$coords[,1]
latitude <- k0rds$coords[,2]
k0.data <- data.frame(longitude, latitude, kappa)
# Define coordinates
coordinates(k0.data) = ~longitude+latitude
# Read data for kappa estimates from rds file and turn into a dataframe:
# - Coordinates are degrees lon and lat
k0rds <- readRDS(sprintf("/Users/tnye/kappa/krige/%s_my_data.rds", model_name))
# Imports
library('geoR')
model <- 'new_model1'
k0_dat_csv <- read.csv(file = sprintf("/Users/tnye/kappa/krige/%s_coords.csv", model))
lon <- k0_dat_csv['Longitude']
lat <- k0_dat_csv['Latitude']
UTMx <- k0_dat_csv['UTMx']
UTMy <- k0_dat_csv['UTMy']
log_k <- k0_dat_csv['log10_kappa']
kappa <- k0_dat_csv['kappa']
covariates <- numeric(length(log_k))
### Longitude Latitude
df <- data.frame("Longitude"=lon, "Latitude"=lat, "data"=kappa, "covariates"=covariates)
data <- as.geodata(df, coords.col=1:2, data.col=3, covar.col=4,
"station_names"=df$station_names, data.names=NULL, covar.names="BAY")
saveRDS(data, file = sprintf("/Users/tnye/kappa/krige/%s_my_data_lonlat.rds", model))
# Imports
library('geoR')
library('pracma')
library('gstat')
library(sp)
# Name of model
model_name <- 'new_model1'
# Read data for kappa estimates from rds file and turn into a dataframe:
# - Coordinates are degrees lon and lat
k0rds <- readRDS(sprintf("/Users/tnye/kappa/krige/%s_my_data_lonlat.rds", model_name))
kappa <- k0rds$data
longitude <- k0rds$coords[,1]
latitude <- k0rds$coords[,2]
k0.data <- data.frame(longitude, latitude, kappa)
# Define coordinates
coordinates(k0.data) = ~longitude+latitude
# Initial values for regression (from Van Houtte et al., 2018)
ini.nug <- 0
ini.sill <- 0.03
ini.range <- 0.1
# Matern order (fixed) (from Van Houtte et al., 2018)
theta <- 0.5
# Make and plot variogram
# k0.vgm = variogram(kappa~1, k0.data)
# k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Mat', ini.range, kappa=theta, nugget=ini.nug))
k0.vgm = variogram(kappa~1, k0.data)
k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Sph', ini.range, nugget=ini.nug))
# Kriging 1 --------------------------------------------------------------------
grid <- read.csv("/Users/tnye/kappa/krige/grid_lonlat.txt")
coordinates(grid) = ~Longitude+Latitude
k0.kriged = krige(kappa~1, k0.data, grid, model = k0.fit)
spplot(k0.kriged["var1.pred"])
# Krige Predictions (in linear, not log10 units)
k0.pred <- k0.kriged$var1.pred
# Krige Standard deviations
k0.stddev <- sqrt(k0.kriged$var1.var)
# Make Dataframe
df <- data.frame("Latitude"=grid[,2], "Longitude"=grid[,1], "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
write.csv(df, sprintf("/Users/tnye/kappa/krige/%s_krige_k0_linear.csv", model_name), row.names = FALSE)
# Make Dataframe
df <- data.frame("Latitude"=grid[,2], "Longitude"=grid[,1], "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
df
# Krige Standard deviations
k0.stddev <- sqrt(k0.kriged$var1.var)
k0.stddev
# Matern order (fixed) (from Van Houtte et al., 2018)
theta <- 0.5
# Make and plot variogram
# k0.vgm = variogram(kappa~1, k0.data)
# k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Mat', ini.range, kappa=theta, nugget=ini.nug))
k0.vgm = variogram(kappa~1, k0.data)
k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Sph', ini.range, nugget=ini.nug))
k0.fit
png(file=sprintf('/Users/tnye/kappa/plots/paper/k0_semivariogram_%s.png',model_name),
width=600, height=350, res=300)
plot(k0.vgm, k0.fit, xlab="Distance (deg)", ylab="Semivariance",cex.lab=.5,cex.axis=.5)
dev.off()
grid <- read.csv("/Users/tnye/kappa/krige/grid_lonlat.txt")
coordinates(grid) = ~Longitude+Latitude
k0.kriged = krige(kappa~1, k0.data, grid, model = k0.fit)
spplot(k0.kriged["var1.pred"])
# Krige Predictions (in linear, not log10 units)
k0.pred <- k0.kriged$var1.pred
# Krige Standard deviations
k0.stddev <- sqrt(k0.kriged$var1.var)
grid[,2]
grid
grid[,2]
grid[:,2]
grid[1,2]
grid(1,2)
grid
gird[1]
grid[1]
grid$Latitude
# Make Dataframe
# df <- data.frame("Latitude"=grid[,2], "Longitude"=grid[,1], "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
df <- data.frame("Latitude"=grid$Latitude, "Longitude"=grid$Longitude, "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
df
write.csv(df, sprintf("/Users/tnye/kappa/krige/%s_krige_k0_linear.csv", model_name), row.names = FALSE)
# Imports
library('geoR')
model <- 'new_model2'
k0_dat_csv <- read.csv(file = sprintf("/Users/tnye/kappa/krige/%s_coords.csv", model))
lon <- k0_dat_csv['Longitude']
lat <- k0_dat_csv['Latitude']
UTMx <- k0_dat_csv['UTMx']
UTMy <- k0_dat_csv['UTMy']
log_k <- k0_dat_csv['log10_kappa']
kappa <- k0_dat_csv['kappa']
covariates <- numeric(length(log_k))
### Longitude Latitude
df <- data.frame("Longitude"=lon, "Latitude"=lat, "data"=kappa, "covariates"=covariates)
data <- as.geodata(df, coords.col=1:2, data.col=3, covar.col=4,
"station_names"=df$station_names, data.names=NULL, covar.names="BAY")
saveRDS(data, file = sprintf("/Users/tnye/kappa/krige/%s_my_data_lonlat.rds", model))
### UTM
df <- data.frame("UTMx"=UTMx, "UTMy"=UTMy, "data"=kappa, "covariates"=covariates)
data <- as.geodata(df, coords.col=1:2, data.col=3, covar.col=4,
"station_names"=df$station_names, data.names=NULL, covar.names="BAY")
saveRDS(data, file = sprintf("/Users/tnye/kappa/krige/%s_my_data_utm.rds", model))
##################################################################################
# R code to read station k0 data and produce a spatially-continuous map for the
# San Francisco Bay area. Code modified from
# https://github.com/cvanhoutte-zz/kappa/blob/master/codes/krige.R
#
# Requires R packages {geoR} and {pracma}.
#
##################################################################################
# Imports
library('geoR')
library('pracma')
library('gstat')
library(sp)
# Name of model
model_name <- 'new_model2'
# Read data for kappa estimates from rds file and turn into a dataframe:
# - Coordinates are degrees lon and lat
k0rds <- readRDS(sprintf("/Users/tnye/kappa/krige/%s_my_data_lonlat.rds", model_name))
kappa <- k0rds$data
longitude <- k0rds$coords[,1]
latitude <- k0rds$coords[,2]
k0.data <- data.frame(longitude, latitude, kappa)
# Define coordinates
coordinates(k0.data) = ~longitude+latitude
# Initial values for regression (from Van Houtte et al., 2018)
ini.nug <- 0
ini.sill <- 0.03
ini.range <- 0.1
# Matern order (fixed) (from Van Houtte et al., 2018)
theta <- 0.5
# Make and plot variogram
# k0.vgm = variogram(kappa~1, k0.data)
# k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Mat', ini.range, kappa=theta, nugget=ini.nug))
k0.vgm = variogram(kappa~1, k0.data)
k0.fit = fit.variogram(k0.vgm, model = vgm(ini.sill, 'Sph', ini.range, nugget=ini.nug))
# Save plot of variogram
png(file=sprintf('/Users/tnye/kappa/plots/paper/k0_semivariogram_%s.png',model_name),
width=600, height=350, res=300)
plot(k0.vgm, k0.fit, xlab="Distance (deg)", ylab="Semivariance",cex.lab=.5,cex.axis=.5)
dev.off()
# Kriging 1 --------------------------------------------------------------------
grid <- read.csv("/Users/tnye/kappa/krige/grid_lonlat.txt")
coordinates(grid) = ~Longitude+Latitude
k0.kriged = krige(kappa~1, k0.data, grid, model = k0.fit)
spplot(k0.kriged["var1.pred"])
# Krige Predictions (in linear, not log10 units)
k0.pred <- k0.kriged$var1.pred
# Krige Standard deviations
k0.stddev <- sqrt(k0.kriged$var1.var)
# Make Dataframe
# df <- data.frame("Latitude"=grid[,2], "Longitude"=grid[,1], "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
df <- data.frame("Latitude"=grid$Latitude, "Longitude"=grid$Longitude, "pred_k0"=k0.pred, "k0_stddev"=k0.stddev)
write.csv(df, sprintf("/Users/tnye/kappa/krige/%s_krige_k0_linear.csv", model_name), row.names = FALSE)
